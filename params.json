{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Should testing for .net - the way Asserting *Should* be","body":"Shouldly\r\n========\r\n\r\n### How asserting *Should* be\r\n\r\nThis is the old *Assert* way: \r\n\r\n```C#    \r\nAssert.That(contestant.Points, Is.EqualTo(1337));\r\n```\r\n    \r\nFor your troubles, you get this message, when it fails:\r\n\r\n    Expected 1337 but was 0\r\n\r\nHow it **Should** be:\r\n\r\n```C#\r\ncontestant.Points.ShouldBe(1337);\r\n```\r\n    \r\nWhich is just syntax, so far, but check out the message when it fails:\r\n\r\n    contestant.Points should be 1337 but was 0\r\n\r\nIt might be easy to underestimate how useful this is. Another example, side by side:\r\n\r\n```C#\r\n    Assert.Equals(2, map.IndexOf(\"boo\"));    // -> Expected 2 but was 1\r\n    map.IndexOf(\"boo\").ShouldBe(2);          // -> map.IndexOf(\"boo\") \r\n                                             //      should be 2 \r\n                                             //      but was 1\r\n```\r\n\r\n**Shouldly** uses the variables within the *ShouldBe* statement to report on errors, which makes diagnosing easier.\r\n\r\nAnother example, if you compare two collections:\r\n    \r\n```C#\r\n    (new[] { 1, 2, 3 }).ShouldBe(new[] { 1, 2, 4 });\r\n``` \r\nand it fails because they're different, it'll show you the differences between the two collections:\r\n        should be\r\n    [1, 2, 4]\r\n        but was\r\n    [1, 2, 3]\r\n        difference\r\n    [1, 2, *3*]\r\n\r\nIf you want to check that a particular call does/does not throw an exception, it's as simple as:\r\n    \r\n```C#\r\n    Should.Throw<ArgumentOutOfRangeException>(() => widget.Twist(-1));\r\n```\r\n    \r\nThen if it chucks a wobbly, you have access to the exception to help debug what the underlying cause was.\r\n\r\nOther *Shouldly* features:\r\n\r\n    ## Equality\r\n         ShouldBe\r\n         ShouldNotBe\r\n         ShouldBeGreaterThan(OrEqualTo)\r\n         ShouldBeLessThan(OrEqualTo)\r\n         ShouldBeTypeOf<T>\r\n\r\n    ## Enumerable\r\n     \t ShouldBe(with Tolerance)\r\n         ShouldContain\r\n         ShouldContain(predicate)\r\n         ShouldNotContain\r\n         ShouldNotContain(predicate)\r\n         ShouldBeEmpty\r\n         ShouldNotBeEmpty\r\n\r\n    ## String\r\n         ShouldBeCloseTo\r\n         ShouldStartWith\r\n         ShouldEndWith\r\n         ShouldContain\r\n         ShouldNotContain\r\n         ShouldContainWithoutWhitespace\r\n         ShouldMatch\r\n\r\n    ## Dictionary\r\n         ShouldContainKeyShouldContainKeyAndValue\r\n         ShouldNotContainKey\r\n         ShouldNotContainKeyAndValue\r\n\t\r\n    ## Exceptions\r\n         Should.Throw<T>(Action)\r\n         Should.NotThrow(Action)\r\n","name":"Shouldly"}